require('dotenv').config()
const cron = require('node-cron')

// Import services
const AuthService = require('../services/auth.service.js')
const S3Service = require('../services/s3.service.js')
const LoggingService = require('../services/logging.service.js')
const DataService = require('../services/data.service.js')
const ContactService = require('../services/contact.service.js')
const PDFService = require('../services/pdf.service.js')

class EmnrdController {
  constructor() {
    // Initialize services
    this.loggingService = new LoggingService()
    this.authService = new AuthService()
    this.s3Service = new S3Service(this.authService, this.loggingService)
    this.dataService = new DataService(this.authService, this.loggingService)
    this.contactService = new ContactService(this.authService, this.s3Service)
    this.pdfService = new PDFService(this.authService, this.s3Service, this.loggingService)
    
    // State
    this.filesToProcess = []
    this.appScheduleRunning = false
    
    // Initialize cron job
    this.initializeCronJob()
  }

  // HTTP Route Handlers
  async test(req, res) {
    try {
      this.appScheduleRunning = true
      const applicantNames = this.dataService.getApplicantNames()
      
      for (let j = 0; j < applicantNames.length; j++) {
        const applicant = applicantNames[j]
        console.log(`üîç Processing applicant: ${applicant}`)

        // Ensure we have a valid token
        if (!this.authService.getToken()) {
          await this.authService.login()
        }

        const response = await this.dataService.callForData(applicant)

        if (!response || !response.data || !Array.isArray(response.data.Items)) {
          console.warn(`‚ö†Ô∏è No valid data returned for applicant "${applicant}". Skipping...`)
          await this.loggingService.writeMessage('missingItems', `No Items for ${applicant}`)
          continue
        }

        const items = response.data.Items
        console.log(`‚úÖ Retrieved ${items.length} items for ${applicant}`)

        const allPdfs = items.flatMap(item => item.ImagingFiles || [])

        if (!allPdfs.length) {
          console.log(`üì≠ No ImagingFiles found for "${applicant}".`)
          continue
        }

        for (let i = 0; i < allPdfs.length; i++) {
          const pdf = allPdfs[i]
          const s3Key = `pdfs/${applicant}/${pdf.FileName}`
          
          if(pdf.FileSize > 500000) {
            try {
              this.filesToProcess.push(s3Key)
              console.log(`‚¨áÔ∏è Uploading ${pdf.FileName} to S3...`)
              await this.s3Service.uploadToS3(pdf.Url, s3Key)
              console.log(`‚úÖ Uploaded: ${pdf.FileName}`)
            } catch (uploadErr) {
              console.error(`‚ùå Upload failed for ${pdf.FileName}: ${uploadErr.message}`)
              await this.loggingService.writeMessage('uploadFail', uploadErr.message + ' ' + pdf.FileName)
            }
          } else {
            console.log(`${pdf.FileName} skipping due to file size`)
          }
        }
      }

      this.appScheduleRunning = false
      
      if (res) {
        return res.status(200).send({ message: 'PDF processing completed successfully.' })
      }

      return true;

    } catch (err) {
      console.error(`üí• Fatal error in test(): ${err.message}`)
      await this.loggingService.writeMessage('testFatal', err.message)

      if (res) {
        return res.status(500).send({ error: err.message })
      }

      return false
    }
  }

  async processList(req, res) {
    try {
      const folder = (req.query.folder || 'pdfs').replace(/\/?$/, '/')
      const results = await this.s3Service.listFiles(folder)
      res.status(200).send('ok')
    } catch (err) {
      console.error("Error listing files:", err)
      await this.loggingService.writeMessage('s3Error', err)
      return res.status(500).send(err)
    }
  }

  getStatus(req, res) {
    res.status(200).send(this.appScheduleRunning)
  }

  async getPdfList(req, res) {
    try {
      const folder = (req.query.folder || 'pdfs').replace(/\/?$/, '/')
      console.log(folder + '<----')
      const results = await this.s3Service.listFiles(folder)
      
      if (results.length === 0) {
        console.log("No files found in the specified folder.")
        await this.loggingService.writeMessage('s3error', 'Folder is empty or does not exist')
        return res.status(404).send('Not Found')
      }

      res.status(200).send(results)
    } catch (err) {
      console.error("Error listing files:", err)
      await this.loggingService.writeMessage('s3Error', err)
      return res.status(500).send(err)
    }
  }

  async extractContacts(req, res) {
    try {
      const { pdfKeys } = req.body
      
      if (!pdfKeys || !Array.isArray(pdfKeys) || pdfKeys.length === 0) {
        return res.status(400).json({
          success: false,
          message: 'pdfKeys array is required'
        })
      }

      const result = await this.pdfService.processContactsFromPdfs(pdfKeys)
      
      res.status(result.success ? 200 : 400).json(result)
    } catch (error) {
      res.status(500).json({
        success: false,
        message: `Server error: ${error.message}`
      })
    }
  }

  async processSingleFile(req, res) {
    try {
      const { pdfKey, outputBucket } = req.body;
        
      if (!pdfKey) {
        return res.status(400).json({
          success: false,
          message: 'pdfKey is required'
        });
      }

      const result = await this.pdfService.processSingleFile(pdfKey, outputBucket)
      res.json(result)

    } catch (error) {
      res.status(500).json({
        success: false,
        message: error.message
      });
    }
  }

  async getByKey(req, res) {
    const key = req.query.key

    if (!key) {
      return res.status(400).send('Missing key')
    }

    try {
      const data = await this.s3Service.getFileMetadata(key)
      res.status(200).send(data)
    } catch (err) {
      console.error('Error fetching metadata:', err)
      await this.loggingService.writeMessage('s3Error', err)

      if (err.name === 'NotFound') {
        return res.status(404).send('File not found')
      }

      return res.status(500).send('Error fetching PDF metadata')
    }
  }

  // Contact management endpoints
  async getContacts(req, res) {
    try {
      const {
        limit = 25,
        lastEvaluatedKey,
        company,
        record_type,
        acknowledged,
        islegal
      } = req.query

      const result = await this.contactService.queryContacts({
        limit: parseInt(limit),
        lastEvaluatedKey: lastEvaluatedKey ? JSON.parse(decodeURIComponent(lastEvaluatedKey)) : null,
        filters: {
          company,
          record_type,
          acknowledged: acknowledged !== undefined ? acknowledged === 'true' : undefined,
          islegal: islegal !== undefined ? islegal === 'true' : undefined
        }
      })

      res.status(200).json(result)

    } catch (error) {
      console.error('Error fetching contacts:', error.message)
      res.status(500).json({
        success: false,
        message: `Error fetching contacts: ${error.message}`
      })
    }
  }

  async getContactStats(req, res) {
    try {
      const stats = await this.contactService.queryContactStatistics()
      res.status(200).json(stats)
    } catch (error) {
      console.error('Error fetching contact stats:', error.message)
      res.status(500).json({
        success: false,
        message: `Error fetching stats: ${error.message}`
      })
    }
  }

  async updateContactStatus(req, res) {
    try {
      const { pkey, skey, acknowledged, islegal } = req.body

      if (!pkey || !skey) {
        return res.status(400).json({
          success: false,
          message: 'pkey and skey are required'
        })
      }

      const updateResult = await this.contactService.updateContact(pkey, skey, { acknowledged, islegal })
      
      res.status(updateResult.success ? 200 : 400).json(updateResult)

    } catch (error) {
      console.error('Error updating contact:', error.message)
      res.status(500).json({
        success: false,
        message: `Update failed: ${error.message}`
      })
    }
  }

  // Debug endpoints
  async testDynamoClient(req, res) {
    try {
      console.log('üß™ Testing DynamoClient...')
      res.status(200).json({
        success: true,
        message: 'DynamoClient test successful'
      })
    } catch (error) {
      res.status(500).json({
        success: false,
        message: `DynamoClient test failed: ${error.message}`
      })
    }
  }

  async testContacts(req, res) {
    try {
      const result = await this.contactService.queryContacts({ limit: 5 })
      res.status(200).json(result)
    } catch (error) {
      res.status(500).json({
        success: false,
        message: error.message
      })
    }
  }

  async debugMethods(req, res) {
    try {
      const methods = Object.getOwnPropertyNames(Object.getPrototypeOf(this))
      res.status(200).json({
        success: true,
        availableMethods: methods
      })
    } catch (error) {
      res.status(500).json({
        success: false,
        message: error.message
      })
    }
  }

  // Main processing workflow
  async processFilesInBucket() {
    this.filesToProcess = []
    try {
      console.log(`[${new Date().toISOString()}] Good morning! Running Process Files`);
      console.log('-----------------------------------')
      console.log('process files')
      
      console.log('-----------------------------------')
      console.log('ü§ñ Starting Claude contact extraction...')
      
      const contactExtractionResult = await this.pdfService.processContactsFromPdfs(this.filesToProcess)
      
      if (contactExtractionResult.success) {
        console.log('‚úÖ Claude contact extraction completed successfully!')
        console.log(`üìä Extracted ${contactExtractionResult.contactCount} contacts`)
      } else {
        console.log('‚ùå Claude contact extraction failed:', contactExtractionResult.message)
      }
      
      console.log('files done processing')
      this.appScheduleRunning = false
    } catch (e) {
      console.log('----------- Failure ---------------')
      console.log(e)
      await this.loggingService.writeMessage('scheduleFailed', e.message)
      console.log('----------- Failure ---------------')
      this.appScheduleRunning = false
    }
  }

  // Cron job initialization
  initializeCronJob() {
    // Every Monday 5 PM (setting to tuesday for testing)
    //cron.schedule('0 22 * * 2', async () => {
    cron.schedule('5 11 * * *', async () => {
      this.filesToProcess = []
      try {
        console.log(`[${new Date().toISOString()}] Good morning! Running daily job at 5 PM CST`);

        await this.authService.writeDynamoMessage({ 
          pkey: 'schedule#pdfDownload',
          skey: 'schedule#start',
          origin: 'scheduler', 
          type:'system', 
          data: `SUCCESS: Started Job`
        })

        console.log('Start download pdf Success')
        
        this.appScheduleRunning = true
        await this.loggingService.writeMessage('downloadStart', 'started')
        await this.test()
        await this.loggingService.writeMessage('downloadComplete', 'success')
        

        await this.authService.writeDynamoMessage({ 
          pkey: 'schedule#pdfDownload',
          skey: 'schedule#complete',
          origin: 'scheduler', 
          type:'system', 
          data: `SUCCESS: PDFs Downloaded`
        })

        console.log('completed pdf Success')
        console.log('-----------------------------------')
        console.log('process files')
        
        console.log('-----------------------------------')
        console.log('ü§ñ Starting Claude contact extraction...')

        await this.authService.writeDynamoMessage({ 
          pkey: 'schedule#claudeStart',
          skey: 'schedule#start',
          origin: 'claude', 
          type:'system', 
          data: `SUCCESS: Claude Started`
        })

        const contactExtractionResult = await this.pdfService.processContactsFromPdfs(this.filesToProcess)
        
        if (contactExtractionResult.success) {
          console.log('‚úÖ Claude contact extraction completed successfully!')
          console.log(`üìä Extracted ${contactExtractionResult.contactCount} contacts`)
          await this.authService.writeDynamoMessage({ 
            pkey: 'schedule#claudeStart',
            skey: 'schedule#complete',
            origin: 'claude', 
            type:'system', 
            data: `SUCCESS: Claude Completed`
          })

          console.log('-----------------------------------')
          console.log('üìä Starting CSV processing to DynamoDB...')

          await this.authService.writeDynamoMessage({ 
            pkey: 'schedule#csvProcessing',
            skey: 'schedule#start',
            origin: 'csvProcessor', 
            type:'system', 
            data: `SUCCESS: CSV Processing Started`
          })

          // Process CSV files and store in DynamoDB
          const csvProcessingResult = await this.contactService.processCSVsToDynamo()

          if (csvProcessingResult.success) {
            console.log('‚úÖ CSV processing to DynamoDB completed successfully!')
            console.log(`üìä Processed ${csvProcessingResult.totalRecordsProcessed} records from ${csvProcessingResult.filesProcessed} CSV files`)
            
            await this.authService.writeDynamoMessage({ 
              pkey: 'schedule#csvProcessing',
              skey: 'schedule#complete',
              origin: 'csvProcessor', 
              type:'system', 
              data: `SUCCESS: ${csvProcessingResult.message}`
            })
          } else {
            console.log('‚ùå CSV processing to DynamoDB failed:', csvProcessingResult.message)
            
            await this.authService.writeDynamoMessage({ 
              pkey: 'schedule#csvProcessing',
              skey: 'schedule#error',
              origin: 'csvProcessor', 
              type:'system', 
              data: `FAILED: ${csvProcessingResult.message}`
            })
          }

        } else {
          console.log('‚ùå Claude contact extraction failed:', contactExtractionResult.message)
          await this.authService.writeDynamoMessage({ 
            pkey: 'schedule#claudeStart',
            skey: 'schedule#error',
            origin: 'claude', 
            type:'system', 
            data: `FAILED: ${contactExtractionResult.message}`
          })
        }
        
        console.log('files done processing')
        this.appScheduleRunning = false
      } catch (e) {
        console.log('----------- Failure ---------------')
        console.log(e)
        await this.loggingService.writeMessage('scheduleFailed', e.message)
        
        await this.authService.writeDynamoMessage({ 
          pkey: 'schedule#failed',
          skey: 'error#failed',
          origin: 'schedule', 
          type:'system', 
          data: `FAILURE: ${e.message}`
        })
        console.log('----------- Failure ---------------')
        this.appScheduleRunning = false
      }
    })
  }
}

// Create single instance
const emnrdController = new EmnrdController()

// Export both the Controller class and controller function for routes
module.exports.Controller = { EmnrdController: emnrdController }
module.exports.controller = (app) => {
  // PDF and file management
  app.get('/v1/pdflist', (req, res) => emnrdController.getPdfList(req, res))
  app.get('/v1/pdfbykey', (req, res) => emnrdController.getByKey(req, res))
  app.get('/v1/running', (req, res) => emnrdController.getStatus(req, res))
  app.get('/v1/force', (req, res) => emnrdController.test(req, res))
  app.get('/v1/theprocess', (req, res) => emnrdController.processList(req, res))
  app.post('/v1/extract-contacts', (req, res) => emnrdController.extractContacts(req, res))
  app.post('/v1/processsingle', (req, res) => emnrdController.processSingleFile(req, res))

  // Contact management endpoints
  app.get('/v1/contacts', (req, res) => emnrdController.getContacts(req, res))
  app.get('/v1/contacts/stats', (req, res) => emnrdController.getContactStats(req, res))
  app.put('/v1/contacts/update', (req, res) => emnrdController.updateContactStatus(req, res))
  
  // Debug endpoints
  app.get('/v1/test-dynamo', (req, res) => emnrdController.testDynamoClient(req, res))
  app.get('/v1/debug-methods', (req, res) => emnrdController.debugMethods(req, res))
  app.get('/v1/test-contacts', (req, res) => emnrdController.testContacts(req, res))
}